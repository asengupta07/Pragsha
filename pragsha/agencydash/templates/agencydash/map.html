{% extends 'agencydash/layout.html' %}

{% block title %}
    Map
{% endblock %}

{% block links %}
    <script type='text/javascript' src='https://www.bing.com/api/maps/mapcontrol?key=AoCUncNX_-l6FfT1nHyketx4jOn1zrAIiBzGfYei8zgT9CUyVqxRckBBMZYI18Zx'></script>
{% endblock %}

{% block main %}
    <div id="map" style="width: 100%; height: 400px;"></div>
    <script>
        function initMap() {
            var map = new Microsoft.Maps.Map(document.getElementById('map'), {
                credentials: 'AoCUncNX_-l6FfT1nHyketx4jOn1zrAIiBzGfYei8zgT9CUyVqxRckBBMZYI18Zx'
            });

            // Add a pushpin for the user's location
            navigator.geolocation.getCurrentPosition(function (position) {
                var userLocation = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude);
                var userPushpin = new Microsoft.Maps.Pushpin(userLocation, { color: 'green', title: '{{ agency_name|safe }}' });
                map.entities.push(userPushpin);
            });

            // Parse the JSON data passed from the view
            var markerData = JSON.parse('{{ marker_data|safe }}');

            for (var i = 0; i < markerData.length; i++) {
                var location = new Microsoft.Maps.Location(markerData[i].latitude, markerData[i].longitude);
                var pushpin = new Microsoft.Maps.Pushpin(location, { title: markerData[i].name });
                map.entities.push(pushpin);
            }

            var yellowMarkerData = JSON.parse('{{ yellow_marker_data|safe }}');

            for (var i = 0; i < yellowMarkerData.length; i++) {
                var yellowLocation = new Microsoft.Maps.Location(yellowMarkerData[i].latitude, yellowMarkerData[i].longitude);
                var yellowPushpin = new Microsoft.Maps.Pushpin(yellowLocation, { color: 'yellow', title: yellowMarkerData[i].name });
                map.entities.push(yellowPushpin);
            }
        }

        Microsoft.Maps.loadModule('Microsoft.Maps.AutoSuggest', { callback: initMap, errorCallback: function (e) { console.log(e); } });
    </script>

    <div id="result" style="margin-top: 20px;"></div>
</div>

<script>
    // Define JavaScript variables for your Python code
    var threshold_distance = {{ threshold_distance }};
    var start_vertex = "{{ start_vertex }}";
    var latitude1 = {{ latitude1 }};
    var longitude1 = {{ longitude1 }};
    var latitude2 = {{ latitude2 }};
    var longitude2 = {{ longitude2 }};

    // Define the Graph class in JavaScript
    class Graph {
        constructor(vertices) {
            this.vertices = vertices;
            this.edges = [];
        }

        add_edge(u, v, w) {
            this.edges.push([u, v, w]);
        }

        bellman_ford(start) {
            var distances = {};
            this.vertices.forEach(function (vertex) {
                distances[vertex] = Infinity;
            });
            distances[start] = 0;

            for (var _ = 0; _ < this.vertices.length - 1; _++) {
                this.edges.forEach(function (edge) {
                    var u = edge[0];
                    var v = edge[1];
                    var w = edge[2];
                    if (distances[u] !== Infinity && distances[u] + w < distances[v]) {
                        distances[v] = distances[u] + w;
                    }
                });
            }

            this.edges.forEach(function (edge) {
                var u = edge[0];
                var v = edge[1];
                var w = edge[2];
                if (distances[u] !== Infinity && distances[u] + w < distances[v]) {
                    throw "Graph contains a negative weight cycle";
                }
            });

            return distances;
        }
    }

    // Define the haversine function in JavaScript
    function haversine(lat1, lon1, lat2, lon2) {
        var R = 6371.0;
        lat1 = radians(lat1);
        lon1 = radians(lon1);
        lat2 = radians(lat2);
        lon2 = radians(lon2);
        var dlon = lon2 - lon1;
        var dlat = lat2 - lat1;
        var a = Math.sin(dlat / 2) * 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) * 2;
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var distance = R * c;

        return distance;
    }

    // Call the haversine function and perform the Bellman-Ford algorithm
    var distance = haversine(latitude1, longitude1, latitude2, longitude2);
    if (distance < threshold_distance) {
        var graph = new Graph(["Node1", "Node2"]);
        graph.add_edge("Node1", "Node2", distance);

        try {
            var shortest_distances = graph.bellman_ford(start_vertex);
            for (var vertex in shortest_distances) {
                document.getElementById("result").innerHTML += "Shortest distance from " + start_vertex + " to " + vertex + ": " + shortest_distances[vertex] + "<br>";
            }
        } catch (e) {
            document.getElementById("result").innerHTML += e;
        }
    }
</script>
{% endblock %}
